<h1>Geometrijska serija</h1>

<h2>Motivacija</h2>
<p>
Zamislite da imate broj i da ga svaki put pomnožite sa tri.  
Dobijate sledeći broj, pa sledeći... i tako nastaje <b>geometrijska serija</b>.  
</p>

<p>
Ovakvi nizovi su svuda oko nas!   
Na primer:
<ul>
  <li>Bakterije u laboratoriji se mogu utrostručavati svakih nekoliko sati.</li>
  <li>Ulaganje u banci može rasti tri puta u određenom periodu ako se kamata obračunava složeno.</li>
</ul>
Ovakav rast nazivamo <b>eksponencijalni rast</b> – jer brojevi rastu mnogo brže nego kod običnog sabiranja.  
</p>

<p>
Naš zadatak je jednostavan:  
želite da ispišete sve brojeve iz intervala <b>[a, b]</b> koji pripadaju geometrijskoj seriji.  
Prvi broj je <b>a</b>, a svaki sledeći dobijamo množenjem sa 3, sve dok ne pređemo granicu <b>b</b>.
</p>

<h2>Naivno rešenje</h2>
<p>
Možemo krenuti „grubo“ — prolaziti kroz sve brojeve od <b>a</b> do <b>b</b>  
i za svaki proveravati da li je deo serije, tj. da li se može napisati kao <b>a × 3<sup>k</sup></b> za neko <b>k</b>.
</p>

<p>
Ovaj pristup radi, ali je <b>neefikasan</b>.  
Zamislite da tražite brojeve u intervalu od 1 do milion — proveravaćete ogroman broj beskorisnih kandidata.  
Računar bi se nepotrebno mučio, iako zapravo postoji jednostavno pravilo koje „skače“ direktno na tačne brojeve.
</p>

<div class="napomena">
Kao da tražite svaku treću osobu u masi od 1000 ljudi tako što pitate svakog redom — umesto da jednostavno brojite: treći, šesti, deveti...
</div>

<h2>Analiza problema</h2>
<p>
Da ne bismo proveravali sve, posmatrajmo kako izgleda sama serija.  
Vidimo da se svaki sledeći broj lako dobija od prethodnog:
</p>
<ul>
  <li>Prvi broj je <b>a</b>.</li>
  <li>Sledeći broj dobijamo množenjem sa 3.</li>
  <li>Stajemo čim pređemo granicu <b>b</b>.</li>
</ul>

<p>
Dakle, ne moramo „nasumično“ tražiti brojeve — samo pratimo pravilo rasta.  
Ovo je suština <b>induktivnog razmišljanja</b>: ako znamo rešenje za manji slučaj, znamo i kako da dođemo do sledećeg.
</p>

<h2>Pravilan pristup</h2>
<p>
Koristićemo <b>rekurzivni pristup</b> — funkcija poziva samu sebe za sledeći broj u nizu.
</p>
<ul>
  <li><b>Osnovni slučaj:</b> Ako je trenutni broj veći od <b>b</b>, zaustavi se.</li>
  <li><b>Induktivni korak:</b> Ispiši trenutni broj, zatim pozovi funkciju za <b>tri puta veći</b> broj.</li>
</ul>

<p>
Ovim pristupom dobijamo elegantno i brzo rešenje.  
Računar u svakom trenutku zna gde je i odmah prelazi na sledeći broj serije — bez gubljenja vremena.
</p>

<xmp class="primer_ta">
static void GeometrijskaSerija(int x, int b)
{
    if (x > b) return;            // osnovni slučaj
    Console.WriteLine(x);         // ispis trenutnog broja
    GeometrijskaSerija(x * 3, b); // induktivni korak
}

// Primer poziva u Main metodi:
static void Main()
{
    int a = int.Parse(Console.ReadLine());
    int b = int.Parse(Console.ReadLine());
    GeometrijskaSerija(a, b);
}
</xmp>

<h2>Primer</h2>
<p>
Za ulaz:
</p>

<xmp class="primer_ta">
5
50
</xmp>

<p>
Izlaz će biti:
</p>

<xmp class="primer_ta">
5
15
45
</xmp>

<p>
Brojevi 5, 15 i 45 pripadaju seriji jer se svaki sledeći dobija množenjem prethodnog sa 3, a sledeći (135) već prelazi gornju granicu 50.
</p>

<h2>Pitanja za samoevaluaciju</h2>
<ul>
  <li>Zašto nije efikasno proveravati sve brojeve od <b>a</b> do <b>b</b>?</li>
  <li>Šta znači „osnovni slučaj“ u ovom zadatku?</li>
  <li>Kako funkcija zna kada da prestane?</li>
  <li>Zašto je rekurzija ovde prirodniji izbor od petlje?</li>
  <li>Šta bi se desilo ako zaboravimo osnovni slučaj?</li>
</ul>

<div class="zadatak">
<b>Zadatak za vežbu:</b><br>
Implementiraj sličan algoritam gde se sledeći broj dobija množenjem sa 2.  
<br><br>
Na primer, za interval [3, 100], izlaz treba da bude:<br>
<code>3, 6, 12, 24, 48, 96</code>
</div>

<h1>Pomoć – Geometrijska serija</h1>

<div class="napomena">
Seti se: uvek množimo sa 3 dok broj ne pređe gornju granicu <b>b</b>.  
To je ceo algoritam.
</div>

<p>
Osnovni slučaj: kada broj pređe <b>b</b>, više ga ne ispisujemo.  
<br>
Induktivni korak: svaki sledeći broj dobijamo množenjem prethodnog sa 3.
</p>

<p>
Na primer, ako su <b>a = 2</b> i <b>b = 100</b>, niz izgleda ovako:  
<code>2, 6, 18, 54</code>.
</p>

<p>
Ako nisi siguran kako da kreneš, zamisli sledeće korake:
</p>
<ul>
  <li>Počni od broja <b>a</b>.</li>
  <li>Ispiši ga.</li>
  <li>Pomnoži ga sa 3 i ponovi sve dok ne pređe <b>b</b>.</li>
</ul>
