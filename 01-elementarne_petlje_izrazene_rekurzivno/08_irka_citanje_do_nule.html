<h1>Čitanje do nule</h1>

<h2>Motivacija</h2>
<p>
U programiranju se često dešava da ne znamo unapred koliko podataka korisnik želi da unese.  
Na primer, unosimo ocene učenika, troškove tokom dana ili temperature merenja u laboratoriji.  
Kako znati kada je unos gotov?  
</p>

<p>
Zamišljajmo to kao razgovor sa računarom — korisnik unosi brojeve, a računar ih „sluša“ dok ne čuje dogovoreni znak za kraj.  
U ovom zadatku taj znak je broj <b>0</b>.  
Kada unesemo nulu, unos se završava.  
Zadatak je da prebrojimo koliko je brojeva korisnik uneo pre nego što je stigao do nule.
</p>

<div class="napomena">
U svakodnevnim programima ovakav način unosa se često koristi — recimo, dok unosimo stavke računa i na kraju upišemo <b>0</b> da označimo „nema više“.
</div>

<h2>Naivno rešenje</h2>
<p>
Jednostavno rešenje bi bilo da koristimo petlju: čitamo brojeve sve dok ne dobijemo nulu, i brojač uvećavamo za 1 pri svakom unosu.  
Ovaj pristup radi, ali ne pokazuje <b>induktivno razmišljanje</b>.  
Ne razlaže problem na manje korake – samo “vrti” petlju.
</p>

<h2>Analiza problema</h2>
<p>
Pogledajmo problem na induktivan način.  
Zamislimo da algoritam razgovara sa korisnikom:
</p>

<ul>
  <li><b>Osnovni slučaj:</b> Ako uneseni broj = 0 → unos se završava. Nema više brojeva za brojanje → vraćamo 0.</li>
  <li><b>Induktivni korak:</b> Ako uneseni broj ≠ 0 → jedan broj smo pronašli. Brojimo ga (dodajemo 1) i zatim ponovo pozivamo istu metodu da pročita sledeći broj.</li>
</ul>

<p>
Svaki sledeći korak rešava <b>manju verziju istog problema</b> — „koliko je još brojeva ostalo do nule?“  
Na taj način zadatak sam po sebi vodi ka rekurzivnom rešenju.
</p>

<h2>Pravilan pristup</h2>
<p>
Rešenje je kratko i elegantno jer koristi rekurziju da „pamti“ koliko smo brojeva pročitali.  
Računar pamti svaki poziv funkcije dok ne dođe do nule — tada se vraća unazad i sabira 1 po 1, kao da broji unazad korake koje je prešao.
</p>

<xmp class="primer_ta">
static int Prebroj()
{
    int x = int.Parse(Console.ReadLine());
    if (x == 0) return 0;           // osnovni slučaj
    return 1 + Prebroj();           // induktivni korak
}

// Primer poziva u Main metodi:
static void Main()
{
    int rezultat = Prebroj();
    Console.WriteLine(rezultat);
}
</xmp>

<div class="napomena">
Obratite pažnju: svaki novi poziv funkcije „pamti“ da je pročitao jedan broj više.  
Tek kada unesemo 0, sve se funkcije redom zatvaraju i sabiraju koliko ih je bilo.
</div>

<h2>Primer 1</h2>
<xmp class="primer_ta">
Ulaz:
5
-675
123
0

Izlaz:
3
</xmp>

<h2>Primer 2</h2>
<xmp class="primer_ta">
Ulaz:
0

Izlaz:
0
</xmp>

<p>
U prvom primeru, program broji tri broja pre nego što je unesena nula.  
U drugom primeru, korisnik odmah unosi nulu, pa program ispisuje 0.
</p>

<h2>Pitanja za samoevaluaciju</h2>
<ul>
  <li>Šta predstavlja osnovni slučaj u ovom zadatku i zašto je važan?</li>
  <li>Kako znamo da će se program sigurno završiti?</li>
  <li>Zašto rekurzivni pristup prirodno modeluje unos dok se ne unese nula?</li>
  <li>Kako biste izmenili algoritam da broji samo pozitivne brojeve?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
Napiši rekurzivnu metodu koja računa <b>zbir</b> svih brojeva unetih do nule.  
Na primer, za unos 5, -3, 7, 0 → zbir = 9.
</div>

<h1>Pomoć – Čitanje do nule</h1>

<div class="napomena">
Ovde ne znamo koliko će brojeva biti uneto unapred — unos traje dok se ne pojavi nula.
</div>

<p>
<b>Osnovni slučaj:</b> ako unesemo 0 → vraćamo 0 (završavamo unos).  
<br>
<b>Induktivni korak:</b> ako unesemo broj ≠ 0 → dodajemo 1 i pozivamo funkciju ponovo.
</p>

<p>
Zamisli da algoritam kao da se penje stepenicama —  
svaki novi broj je jedan korak više.  
Kada dođe nula, staje i počinje da broji koliko je stepenika prešao.
</p>

<p>
Na primer, za unos: 7, 4, 9, 0:
</p>

<ul>
  <li>Prebroj(7) → 1 + Prebroj(4)</li>
  <li>Prebroj(4) → 1 + Prebroj(9)</li>
  <li>Prebroj(9) → 1 + Prebroj(0)</li>
  <li>Prebroj(0) → 0</li>
</ul>

<p>Ukupan rezultat = 3.</p>

<div class="napomena">
Zapamti: <b>rekurzija pamti korake</b> koje je prešla.  
Kada dostigne osnovni slučaj (nulu), počinje da se „odmotava“ i sabira sve korake unazad.
</div>
