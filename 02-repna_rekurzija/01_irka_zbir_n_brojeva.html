<h1>Zbir n brojeva</h1>

<h2>Motivacija</h2>
<p>
Često je potrebno izračunati zbir većeg broja elemenata.  
Na primer, želimo da saberemo rezultate ispita svih učenika u odeljenju kako bismo kasnije izračunali prosečan broj bodova.  
U drugim situacijama, zbir može predstavljati ukupan trošak na računu, broj bodova u igrici ili ukupno vreme koje smo proveli u učenju tokom nedelje.  
</p>

<p>
Na prvi pogled, deluje da je dovoljno samo redom sabirati brojeve.  
Ali, hajde da problem sagledamo <b>induktivno</b> — korak po korak, kao što to radi računar.
</p>

<div class="napomena">
Kada učimo da razmišljamo induktivno, mi u stvari učimo kako da veliki problem razložimo na više jednostavnih koraka koji se prirodno ponavljaju.
</div>

<h2>Naivno rešenje</h2>
<p>
Najjednostavnije rešenje bilo bi da koristimo petlju i redom sabiramo brojeve.  
Iako to radi, ovakav pristup ne otkriva <b>zašto</b> rešenje funkcioniše niti razvija način razmišljanja koji nam kasnije pomaže kod složenijih zadataka.
</p>

<h2>Analiza problema</h2>
<p>
Zbir <i>n</i> brojeva može se posmatrati kao zbir prvih <i>n−1</i> brojeva plus poslednji broj.  
Drugim rečima, da bismo izračunali zbir svih brojeva, dovoljno je da znamo zbir prethodnih i dodamo poslednji.
</p>

<p>
Na primer, za brojeve 10, -3, 2, 4:
</p>

<xmp class="primer_ta">
Zbir(4) = Zbir(3) + 4
Zbir(3) = Zbir(2) + 2
Zbir(2) = Zbir(1) + (-3)
Zbir(1) = 10
</xmp>

<div class="napomena">
Vidimo da se problem prirodno smanjuje – svodimo zbir 4 broja na zbir 3, pa 2, pa 1.  
To je upravo suština induktivnog pristupa: rešavamo jednostavniji slučaj i nadovezujemo se na njega.
</div>

<h2>Pravilan pristup</h2>
<p>
Ovo je idealan primer za <b>induktivno–rekurzivnu konstrukciju</b> algoritma.  
Rekurzija ovde ima vrlo prirodnu logiku:
</p>

<ul>
  <li><b>Osnovni slučaj:</b> Ako sabiramo samo jedan broj — zbir je taj broj.</li>
  <li><b>Induktivni korak:</b> Ako znamo zbir prvih n−1 brojeva, dodamo poslednji i dobijemo zbir svih n brojeva.</li>
</ul>

<xmp class="primer_ta">
static int Zbir(int[] niz, int n)
{
    if (n == 1) return niz[0];             // osnovni slučaj
    return Zbir(niz, n - 1) + niz[n - 1];  // induktivni korak
}

// Primer poziva u Main metodi:
static void Main()
{
    int[] brojevi = { 10, -3, 2, 4 };
    int rezultat = Zbir(brojevi, brojevi.Length);
    Console.WriteLine(rezultat); // Ispis: 13
}
</xmp>

<div class="napomena">
Rekurzija nam omogućava da razmišljamo kao čovek:  
„Znam zbir prvih nekoliko brojeva, pa ću samo dodati sledeći.“
</div>

<h2>Primer</h2>
<p>
Za niz brojeva:
</p>
<xmp class="primer_ta">
10
-3
2
4
</xmp>

<p>
Izlaz je:
</p>
<xmp class="primer_ta">
13
</xmp>

<p>
Računar računa ovako:
</p>
<ul>
  <li>Zbir(1) = 10</li>
  <li>Zbir(2) = 10 + (-3) = 7</li>
  <li>Zbir(3) = 7 + 2 = 9</li>
  <li>Zbir(4) = 9 + 4 = 13</li>
</ul>

<h2>Pitanja za samoevaluaciju</h2>
<ul>
  <li>Zašto je osnovni slučaj potreban u rekurziji?</li>
  <li>Šta predstavlja induktivni korak u ovom zadatku?</li>
  <li>Kako rekurzija "pamti" gde je stala?</li>
  <li>Kako bi izgledalo isto rešenje, ali bez rekurzije (sa petljom)?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Izmeni algoritam tako da računa <b>proizvod</b> n brojeva umesto zbira.<br><br>
2. Napiši verziju algoritma koja računa zbir <b>samo pozitivnih</b> brojeva iz niza.<br><br>
3. Objasni zašto se induktivni pristup u oba slučaja primenjuje na isti način.
</div>

<h1>Pomoć – Zbir n brojeva</h1>

<div class="napomena">
Podseti se: induktivno razmišljanje znači da se polazi od poznatog slučaja (najmanji problem)
i zatim pravi korak koji povezuje taj slučaj sa sledećim.
</div>

<p>
Osnovni slučaj: kada imamo samo jedan broj, zbir je jednak tom broju.  
<br>
Induktivni korak: ako znamo zbir prvih n−1 brojeva, zbir svih n brojeva dobijamo dodavanjem poslednjeg.
</p>

<p>
Na primer:
</p>
<ul>
  <li>Zbir(1) = 10</li>
  <li>Zbir(2) = Zbir(1) + (-3) = 7</li>
  <li>Zbir(3) = Zbir(2) + 2 = 9</li>
  <li>Zbir(4) = Zbir(3) + 4 = 13</li>
</ul>

<div class="napomena">
Zamisli da računar sabira brojeve kao da slaže kockice — svaka kockica (broj) dodaje nešto novo, ali se uvek oslanja na ono što je već izračunao.
</div>
