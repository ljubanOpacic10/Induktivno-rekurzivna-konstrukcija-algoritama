<h1>Zbir n brojeva</h1>

<h2>Motivacija</h2>
<p>
Često je potrebno izračunati zbir većeg broja elemenata.  
Na primer, želimo da saberemo rezultate ispita svih učenika u odeljenju kako bismo kasnije izračunali prosečan broj bodova.  
U drugim situacijama, zbir može predstavljati ukupan trošak na računu, broj bodova u igrici ili ukupno vreme koje smo proveli u učenju tokom nedelje.  
</p>

<p>
Na prvi pogled, deluje da je dovoljno samo redom sabirati brojeve.  
Ali, hajde da problem sagledamo <b>induktivno</b> — korak po korak.
</p>

<div class="napomena">
Kada učimo da razmišljamo induktivno, mi u stvari učimo kako da veliki problem razložimo na više jednostavnih koraka koji se prirodno ponavljaju.
</div>

<p>
Zadatak je moguće rešiti i pomoću repno-rekurzivne funkcije, koja je algoritamski veoma slična iterativnom algoritmu. Funkcija je repno-rekurzivna ako se nakon rekurzivnog poziva ne vrše dalja izračunavanja.
Repna rekurzija je značajna zbog toga je mnogi kompilatori programskih jezika mogu automatski pretvoriti
i jednostavno prevesti u iteraciju, čime se dobija i vremenski i memorijski efikasniji algoritam.
</p>

<h2>Naivno rešenje</h2>
<p>
Najjednostavnije rešenje bilo bi da koristimo petlju i redom sabiramo brojeve.  
Iako to radi, ovakav pristup ne otkriva <b>zašto</b> rešenje funkcioniše niti razvija način razmišljanja koji nam kasnije pomaže kod složenijih zadataka.
</p>

<h2>Analiza problema</h2>
<p>
Zbir <i>n</i> brojeva može se posmatrati kao zbir prvih <i>n−1</i> brojeva plus poslednji broj.  
Drugim rečima, da bismo izračunali zbir svih brojeva, dovoljno je da znamo zbir prethodnih i dodamo poslednji.
</p>

<p>
Na primer, za brojeve 10, -3, 2, 4:
</p>

<xmp class="primer_ta">
Zbir(4) = Zbir(3) + 4
Zbir(3) = Zbir(2) + 2
Zbir(2) = Zbir(1) + (-3)
Zbir(1) = 10
</xmp>

<div class="napomena">
Vidimo da se problem prirodno smanjuje – svodimo zbir 4 broja na zbir 3, pa 2, pa 1.  
To je upravo suština induktivnog pristupa: rešavamo jednostavniji slučaj i nadovezujemo se na njega.
</div>

<h2>Pravilan pristup</h2>
<p>
Ovo je idealan primer za <b>induktivno–rekurzivnu konstrukciju</b> algoritma.  
Rekurzija ovde ima vrlo prirodnu logiku:
</p>

<ul>
  <li><b>Osnovni slučaj:</b> Ako sabiramo samo jedan broj — zbir je taj broj.</li>
  <li><b>Induktivni korak:</b> Ako znamo zbir prvih n−1 brojeva, dodamo poslednji i dobijemo zbir svih n brojeva.</li>
</ul>

<xmp class="primer_ta">
using System;

class Program
{
  // Repno-rekurzivna funkcija za zbir n brojeva
  static int UcitajISaberiNBrojeva(int n, int zbir)
  {
    if (n == 0)
      return zbir;
    int broj = int.Parse(Console.ReadLine());
    return UcitajISaberiNBrojeva(n - 1, zbir + broj);
  }

  // Preklopljena funkcija za inicijalni poziv
  static int UcitajISaberiNBrojeva(int n)
  {
    return UcitajISaberiNBrojeva(n, 0);
  }

  static void Main()
  {
    int n = int.Parse(Console.ReadLine());
    Console.WriteLine(UcitajISaberiNBrojeva(n));
  }
}
</xmp>

<div class="napomena">
Rekurzija nam omogućava da razmišljamo kao čovek:  
„Znam zbir prvih nekoliko brojeva, pa ću samo dodati sledeći.“
</div>

<h2>Primer</h2>
<p>
Za niz brojeva:
</p>
<xmp class="primer_ta">
10
-3
2
4
</xmp>

<p>
Izlaz je:
</p>
<xmp class="primer_ta">
13
</xmp>

<p>
Računar računa ovako:
</p>
<ul>
  <li>Zbir(1) = 10</li>
  <li>Zbir(2) = 10 + (-3) = 7</li>
  <li>Zbir(3) = 7 + 2 = 9</li>
  <li>Zbir(4) = 9 + 4 = 13</li>
</ul>

<h2>Pitanja za samoevaluaciju</h2>
<ul>
  <li>Zašto je osnovni slučaj potreban u rekurziji?</li>
  <li>Šta predstavlja induktivni korak u ovom zadatku?</li>
  <li>Kako rekurzija "pamti" gde je stala?</li>
  <li>Kako bi izgledalo isto rešenje, ali bez rekurzije (sa petljom)?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Izmeni algoritam tako da računa <b>proizvod</b> n brojeva umesto zbira.<br><br>
2. Napiši verziju algoritma koja računa zbir <b>samo pozitivnih</b> brojeva iz niza.<br><br>
3. Objasni zašto se induktivni pristup u oba slučaja primenjuje na isti način.
</div>

<h1>Pomoć – Zbir n brojeva</h1>

<div class="napomena">
Podseti se: induktivno razmišljanje znači da se polazi od poznatog slučaja (najmanji problem)
i zatim pravi korak koji povezuje taj slučaj sa sledećim.
</div>

<p>
Osnovni slučaj: kada imamo samo jedan broj, zbir je jednak tom broju.  
<br>
Induktivni korak: ako znamo zbir prvih n−1 brojeva, zbir svih n brojeva dobijamo dodavanjem poslednjeg.
</p>

<p>
Na primer:
</p>
<ul>
  <li>Zbir(1) = 10</li>
  <li>Zbir(2) = Zbir(1) + (-3) = 7</li>
  <li>Zbir(3) = Zbir(2) + 2 = 9</li>
  <li>Zbir(4) = Zbir(3) + 4 = 13</li>
</ul>

<div class="napomena">
Zamisli da računar sabira brojeve kao da slaže kockice — svaka kockica (broj) dodaje nešto novo, ali se uvek oslanja na ono što je već izračunao.
</div>
