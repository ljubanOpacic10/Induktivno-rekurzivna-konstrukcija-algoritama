<h1>Broj i zbir cifara broja</h1>

<h2>Motivacija</h2>
<p>
Kada pogledamo neki broj, često nas zanima koliko on ima cifara i koliki je njihov zbir.  
Na primer, broj <b>1234</b> ima <b>4 cifre</b>, a njihov zbir je <b>10</b>.  
Ovakvi zadaci su idealni za razmišljanje <b>induktivno</b> — korak po korak.  
</p>

<p>
Broj možemo posmatrati kao niz manjih delova — njegovih cifara.  
Slično kao kad rastavljamo slagalicu: svaka cifra je jedan deo koji doprinosi celini.  
Kroz ovaj zadatak naučićemo kako da broj „razložimo“ i izračunamo osobine poput broja i zbira njegovih cifara.
</p>

<h2>Naivno rešenje</h2>
<p>
Jedna ideja bila bi da broj pretvorimo u string, zatim prolazimo kroz sve karaktere i sabiramo njihove numeričke vrednosti.  
Iako ovo radi, u tom pristupu broj tretiramo kao tekst, a ne kao matematičku celinu.  
Naš cilj je da naučimo kako računar može da razume cifre broja koristeći čiste brojevne operacije.
</p>

<h2>Analiza problema</h2>
<p>
Ako posmatramo broj <i>n</i>, možemo ga razložiti na:
</p>
<ul>
  <li>Poslednju cifru: <code>n % 10</code></li>
  <li>Ostatak broja: <code>n / 10</code></li>
</ul>

<p>
Dakle, ako znamo broj i zbir cifara broja <i>n / 10</i>, možemo jednostavno dodati doprinos poslednje cifre.
</p>

<div class="napomena">
<p><b>Osnovni slučaj:</b> Ako je n = 0, broj cifara i zbir cifara su 0.</p>
<p><b>Induktivni korak:</b> Ako znamo broj i zbir cifara broja n / 10, onda samo dodajemo jednu cifru – n % 10.</p>
</div>

<h2>Pravilan pristup</h2>
<p>
Rešenje se može ostvariti pomoću jednostavne rekurzije koja svaki put "skida" poslednju cifru broja.  
U svakom koraku broj postaje manji, sve dok ne ostane 0.
</p>

<xmp class="primer_ta">
using System;

class Program
{
  // Rekurzivna funkcija za broj i zbir cifara
  static void brojIZbirCifara_(int n, ref int broj, ref int zbir)
  {
    if (n > 0)
    {
      broj++;
      zbir += n % 10;
      brojIZbirCifara_(n / 10, ref broj, ref zbir);
    }
  }

  // Omotač funkcije za lakši poziv
  static void brojIZbirCifara(int n, out int broj, out int zbir)
  {
    broj = 1;
    zbir = n % 10;
    brojIZbirCifara_(n / 10, ref broj, ref zbir);
  }

  // Glavni program
  static void Main()
  {
    int n = int.Parse(Console.ReadLine());
    int broj, zbir;
    brojIZbirCifara(n, out broj, out zbir);
    Console.WriteLine(broj + " " + zbir);
  }
}
</xmp>

<div class="napomena">
Slično kao kada gulimo slojeve luka – svaka rekurzija „odvaja“ po jednu cifru sa kraja broja, dok ne dođemo do osnove (n = 0).
</div>

<h2>Primeri</h2>
<table class="tabela">
<thead>
<tr><th>Ulaz</th><th>Očekivani izlaz</th></tr>
</thead>
<tbody>
<tr><td>123</td><td>3 cifre, zbir = 6</td></tr>
<tr><td>4095</td><td>4 cifre, zbir = 18</td></tr>
<tr><td>7</td><td>1 cifra, zbir = 7</td></tr>
</tbody>
</table>

<h2>Pitanja za samoevaluaciju</h2>
<ul>
  <li>Šta predstavlja osnovni slučaj i zašto je neophodan?</li>
  <li>Zašto koristimo deljenje sa 10 i ostatak pri deljenju sa 10?</li>
  <li>Koja vrednost se dodaje zbiru u svakom koraku rekurzije?</li>
  <li>Kako bi izgledala jedna funkcija koja vraća i broj i zbir cifara istovremeno?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Napiši funkciju koja vraća zbir samo <b>parnih cifara</b> broja.<br><br>
2. Napiši funkciju koja računa <b>proizvod svih cifara</b> broja.<br><br>
3. Napiši funkciju koja proverava da li broj ima više <b>parnih</b> ili <b>neparnih</b> cifara.<br><br>
4. Objasni kako se induktivni pristup koristi u svakom od ovih zadataka.
</div>

<h1>Pomoć – Broj i zbir cifara broja</h1>

<div class="napomena">
Induktivno razmišljanje znači da veliki problem (ceo broj) svodimo na manji (kraći broj) sve dok ne stignemo do trivijalnog slučaja (n = 0).  
U svakom koraku „odsecamo“ poslednju cifru pomoću operacije <code>/ 10</code> i koristimo <code>% 10</code> da vidimo koju smo cifru uklonili.
</div>

<p>
Na primer, za broj <b>4095</b>:
</p>
<ul>
  <li>Poslednja cifra je 5 → zbir = 5</li>
  <li>Preostaje broj 409 → sledeća cifra 9 → zbir = 14</li>
  <li>Preostaje broj 40 → sledeća cifra 0 → zbir = 14</li>
  <li>Preostaje broj 4 → sledeća cifra 4 → zbir = 18</li>
  <li>Preostaje broj 0 → kraj.</li>
</ul>

<div class="napomena">
Kao što vidimo, svaka cifra doprinosi ukupnom zbiru dok rekurzija „putuje“ kroz broj — od zadnje prema prvoj cifri.
</div>
