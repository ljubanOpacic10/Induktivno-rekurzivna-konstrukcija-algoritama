<h1>Stepen broja</h1>

<h2>Motivacija</h2>
<p>
Računanje stepena broja je jedan od najčešćih zadataka u matematici i programiranju.  
Na primer, izraz <b>2³</b> znači da broj 2 treba pomnožiti sam sa sobom tri puta: 2 × 2 × 2 = 8.  
Ova ideja se često javlja i u stvarnom životu – recimo, kada se veličina ćelije udvostručava svaka tri sata, ili kada se broj bakterija umnožava svakim ciklusom rasta.  
To je upravo primer <b>eksponencijalnog rasta</b>.
</p>

<p>
Umesto da odmah koristimo ugrađene funkcije (poput <code>Math.Pow()</code>), hajde da otkrijemo kako se ova operacija može izvesti <b>induktivno</b> – korak po korak, kao što to radi računar „iznutra“.
</p>

<h2>Naivno rešenje</h2>
<p>
Jedan očigledan način bio bi da koristimo petlju koja ponavlja množenje broja <b>x</b> sa samim sobom <b>n</b> puta.  
Ovakav pristup radi, ali ne otkriva <b>logiku iza</b> procesa.  
Kada znamo *zašto* i *kako* algoritam funkcioniše, možemo ga lako proširiti, optimizovati ili modifikovati — i tu dolazi induktivni pristup.
</p>

<h2>Analiza problema</h2>
<p>
Posmatrajmo izraz <b>xⁿ</b>.  
Ako već znamo vrednost <b>xⁿ⁻¹</b>, do rezultata dolazimo jednostavno:
</p>

<p>
<b>xⁿ = x × xⁿ⁻¹</b>
</p>

<p>
Dakle, problem „stepena n“ možemo svesti na manji problem – „stepen n−1“.  
Ovo je suština induktivnog razmišljanja: veći problem rešavamo tako što iskoristimo rešenje manjeg.
</p>

<div class="napomena">
<p><b>Osnovni slučaj</b> — kada je n = 0, rezultat je 1 (jer je svaki broj na nultom stepenu jednak 1).</p>
<p><b>Induktivni korak</b> — ako znamo xⁿ⁻¹, tada je xⁿ = x × xⁿ⁻¹.</p>
</div>

<h2>Pravilan pristup</h2>
<p>
Rešenje možemo zapisati kao rekurzivnu funkciju koja postepeno „gradi“ rezultat.  
U ovom primeru koristićemo <b>repnu rekurziju</b> (tail recursion), jer funkcija nakon rekurzivnog poziva više ne obavlja nikakve dodatne izračune — samo vraća rezultat.
</p>

<p>
Funkcija prima tri parametra:
</p>

<div class="napomena">
<p><b>x</b> — broj koji stepenujemo</p>
<p><b>s</b> — trenutni rezultat (početno 1, jer je neutralan element za množenje)</p>
<p><b>n</b> — preostali broj množenja</p>
</div>

<p>
Kada n postane 0, to znači da smo uradili sva potrebna množenja i rezultat vraćamo kao gotov.
</p>

<xmp class="primer_ta">
double Stepen(double x, double s, int n)
{
    if (n == 0)
        return s;                 // osnovni slučaj
    return Stepen(x, s * x, n - 1); // induktivni korak
}

double Stepen(double x, int n)
{
    return Stepen(x, 1.0, n);     // inicijalni poziv
}
</xmp>

<h2>Tok izvršavanja</h2>
<p>
Za x = 2 i n = 3:
</p>
<ul>
  <li>Stepen(2, 1, 3) → još 3 koraka, s = 1</li>
  <li>Stepen(2, 2, 2) → s = 1 × 2 = 2</li>
  <li>Stepen(2, 4, 1) → s = 2 × 2 = 4</li>
  <li>Stepen(2, 8, 0) → kraj rekurzije, rezultat = 8</li>
</ul>

<p>
Dakle, funkcija se završava kada <b>n = 0</b> i vraća konačnu vrednost <b>8</b>.  
I upravo tako „misli“ i računar — korak po korak, od poznatog slučaja ka složenijem.
</p>

<h2>Primeri</h2>
<table class="tabela">
<thead>
<tr><th>Ulaz</th><th>Očekivani izlaz</th></tr>
</thead>
<tbody>
<tr><td>x = 2<br>n = 3</td><td>8.00000</td></tr>
<tr><td>x = 5<br>n = 0</td><td>1.00000</td></tr>
<tr><td>x = 3<br>n = 4</td><td>81.00000</td></tr>
</tbody>
</table>

<h2>Pitanja za samoevaluaciju</h2>
<ul>
  <li>Zašto je osnovni slučaj potreban? Šta bi se desilo da ga izostavimo?</li>
  <li>Zašto funkcija koristi pomoćni parametar <b>s</b>?</li>
  <li>Kako znamo da će rekurzija sigurno stati?</li>
  <li>Kako bi izgledala iterativna verzija ove funkcije?</li>
  <li>Da li se može optimizovati broj rekurzivnih poziva (na primer, pomoću eksponencijacije kvadriranjem)?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Napiši funkciju koja računa xⁿ i kada je n negativan (x⁻ⁿ = 1 / xⁿ).<br><br>
2. Napiši funkciju koja računa kvadrat broja (x²) bez korišćenja rekurzije.<br><br>
3. Napiši funkciju koja računa xⁿ bez dodatnog parametra s (klasična rekurzija).<br><br>
4. Objasni u svakoj varijanti gde se koristi osnovni slučaj, a gde induktivni korak.
</div>

<h1>Pomoć – Stepen broja</h1>

<div class="napomena">
Induktivno razmišljanje znači da razbijemo veliki problem na manji, koji je istog tipa, ali jednostavniji.  
Za stepen broja to znači: da bismo dobili xⁿ, najpre izračunamo xⁿ⁻¹ i zatim ga pomnožimo sa x.
</div>

<p>
Na primer, ako je x = 3 i n = 4:
</p>
<ul>
  <li>3¹ = 3</li>
  <li>3² = 3 × 3 = 9</li>
  <li>3³ = 9 × 3 = 27</li>
  <li>3⁴ = 27 × 3 = 81</li>
</ul>

<p>
Svaki korak koristi rezultat prethodnog — baš kao što indukcija gradi složenije rešenje iz jednostavnijeg.
</p>
