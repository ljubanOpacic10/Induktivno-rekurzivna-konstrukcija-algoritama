<h1>Najniža temperatura</h1>

<h2>Motivacija</h2>
<p>
Zamisli da svakog dana meriš temperaturu i želiš da pronađeš najhladniji dan u mesecu.  
Možeš lako da napišeš petlju koja prolazi kroz sve vrednosti i pamti najmanju,  
ali hajde da vidimo kako se ovaj problem može rešiti <b>induktivno</b> — korak po korak, rekurzijom.
</p>

<p>
Zadatak je odličan primer kako kompjuter „misli“ korak po korak:  
posmatra svaki novi broj, upoređuje ga sa dosadašnjim minimumom, i odlučuje koji je manji.  
Na kraju, dobija najnižu temperaturu – baš kao što bi i čovek prelistavao sve rezultate i zapamtio najniži.
</p>

<h2>Naivno rešenje</h2>
<p>
Najjednostavnije rešenje bilo bi da koristimo petlju i promenljivu koja čuva trenutni minimum.  
Iako radi, ovakav pristup ne pokazuje <b>kako</b> algoritam zapravo „gradi“ rešenje.  
Induktivni pristup nam omogućava da vidimo kako se rezultat razvija —  
od prvog broja, zatim drugog, i tako redom — dok se ne pronađe najmanja vrednost.
</p>

<h2>Analiza problema</h2>
<p>
Ako želimo da pronađemo najmanju vrednost među n brojeva, možemo razmišljati ovako:  
Najmanji od svih n brojeva je onaj koji je manji između poslednjeg učitanog broja i minimuma prethodnih n−1 brojeva.  
Dakle, ako znamo minimum za manji skup, lako možemo izračunati minimum za veći.
</p>

<div class="napomena">
<p><b>Osnovni slučaj</b> — kada je n = 0, nema više brojeva za poređenje i trenutni minimum je konačan rezultat.</p>
<p><b>Induktivni korak</b> — uporedi novi broj sa trenutnim minimumom i manju vrednost prosledi sledećem rekurzivnom pozivu.</p>
</div>

<h2>Pravilan pristup</h2>
<h2>Definicija funkcije</h2>
<p>
Definisaćemo funkciju koja određuje minimum između vrednosti svog prvog prosleđenog parametra i vrednosti <i>n</i> brojeva koji se učitavaju sa standardnog ulaza.
Taj prvi parametar predstavlja trenutnu vrednost minimuma tokom iteracije (i može se inicijalizovati na vrednost +∞, tj. vrednost najvećeg podatka celobrojnog tipa).
</p>
<p>
Ako je <b>n = 0</b>, ta trenutna vrednost minimuma je ujedno i tražena vrednost minimuma svih brojeva (do tada su svi oni učitani i obrađeni).
U suprotnom se učitava naredni broj, poredi se sa vrednošću minimuma i manji od njih se prosleđuje sledećem rekurzivnom pozivu (kao trenutna vrednost minimuma svih do tada učitanih brojeva).
</p>
<div class="napomena">
Prvi parametar možemo inicijalizovati na „beskonačno“ kao na primer <code>int.MaxValue</code> kod celobrojnih vrednosti.
</div>

<h2>Primer izračunavanja</h2>
<p>
Ako se redom učitavaju brojevi 3, 8, 1, 2, 5, izvršiće se sledeće izračunavanje:
</p>
<pre>
Min(5) = Min(∞, 5)
  = Min(min(∞, 3), 4)
  = Min(3, 4)
  = Min(min(3, 8), 3)
  = Min(3, 3)
  = Min(min(3, 1), 2)
  = Min(1, 2)
  = Min(min(1, 2), 1)
  = Min(1, 1)
  = Min(min(1, 5), 0)
  = Min(1, 0)
  = 1.
</pre>

<xmp class="primer_ta">
using System;

class Program
{
  // Rekurzivna funkcija za pronalaženje minimuma
  static int Min(int m, int n)
  {
    if (n == 0)
      return m;
    int t = int.Parse(Console.ReadLine());
    return Min(Math.Min(m, t), n - 1);
  }

  // Pomoćna funkcija za inicijalizaciju minimuma
  static int Min(int n)
  {
    return Min(int.MaxValue, n);
  }

  // Ulazna tačka programa
  static void Main()
  {
    int n = int.Parse(Console.ReadLine());
    Console.WriteLine(Min(n));
  }
}
</xmp>

<h2>Objašnjenje toka izvršavanja</h2>
<p>
Zamisli da unosimo 5 temperatura: 3, 8, 1, 2 i 5.  
Evo kako funkcija „razmišlja“ korak po korak:
</p>

<ul>
  <li>Min(∞, 5) → učitavamo 3 → novi minimum = 3</li>
  <li>Min(3, 4) → učitavamo 8 → minimum ostaje 3</li>
  <li>Min(3, 3) → učitavamo 1 → novi minimum = 1</li>
  <li>Min(1, 2) → učitavamo 2 → minimum ostaje 1</li>
  <li>Min(1, 1) → učitavamo 5 → minimum ostaje 1</li>
  <li>Min(1, 0) → kraj rekurzije → vraća rezultat 1</li>
</ul>

<p>
Kada rekurzija stigne do kraja, rezultat je <b>1</b> —  
to znači da je najniža temperatura među unetima <code>3, 8, 1, 2, 5</code> upravo <b>1</b>.
</p>

<h2>Primeri</h2>
<table class="tabela">
<thead>
<tr><th>Ulaz</th><th>Očekivani izlaz</th></tr>
</thead>
<tbody>
<tr><td>5<br>3 8 1 2 5</td><td>1</td></tr>
<tr><td>4<br>10 7 15 9</td><td>7</td></tr>
<tr><td>3<br>-2 -5 0</td><td>-5</td></tr>
</tbody>
</table>

<h2>Pitanja za samoproveru</h2>
<ul>
  <li>Šta predstavlja osnovni slučaj u ovom algoritmu i zašto je važan?</li>
  <li>Zašto se parametar <code>m</code> prosleđuje kroz svaki poziv funkcije?</li>
  <li>Kako funkcija zna kada treba da se zaustavi?</li>
  <li>Šta bi se desilo ako bismo slučajno koristili <code>n + 1</code> umesto <code>n − 1</code>?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Napiši funkciju koja pronalazi maksimalnu vrednost n brojeva (najvišu temperaturu).<br><br>
2. Prilagodi funkciju tako da brojevi budu u nizu, a ne da se unose sa tastature.<br><br>
3. Napiši verziju koja računa razliku između maksimalne i minimalne vrednosti.<br><br>
4. Objasni kako se u svakom od ovih zadataka koristi induktivni princip.
</div>

<h1>Pomoć – Najniža temperatura</h1>

<div class="napomena">
Induktivni pristup znači da rešenje gradiš postepeno.  
Svaki novi broj se poredi sa trenutnim minimumom — manji od njih postaje „privremeni rezultat“.  
Kada više nema brojeva za poređenje, algoritam vraća konačnu vrednost minimuma.
</div>

<p>
Ako ti je teško da razumeš tok, probaj sam da simuliraš nekoliko koraka sa manjim brojem ulaza (na primer 3 broja).  
Zapiši svaki poziv funkcije i vrednost koju ona vraća — tako ćeš videti kako se rekurzija „odmotava“ i dođe do konačnog rešenja.
</p>
