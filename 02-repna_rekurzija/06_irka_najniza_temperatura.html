<h1>Najniža temperatura</h1>

<h2>Motivacija</h2>
<p>
Zamisli da svakog dana meriš temperaturu i želiš da pronađeš najhladniji dan u mesecu.  
Možeš lako da napišeš petlju koja prolazi kroz sve vrednosti i pamti najmanju,  
ali hajde da vidimo kako se ovaj problem može rešiti <b>induktivno</b> — korak po korak, rekurzijom.
</p>

<p>
Zadatak je odličan primer kako kompjuter „misli“ korak po korak:  
posmatra svaki novi broj, upoređuje ga sa dosadašnjim minimumom, i odlučuje koji je manji.  
Na kraju, dobija najnižu temperaturu – baš kao što bi i čovek prelistavao sve rezultate i zapamtio najniži.
</p>

<h2>Naivno rešenje</h2>
<p>
Najjednostavnije rešenje bilo bi da koristimo petlju i promenljivu koja čuva trenutni minimum.  
Iako radi, ovakav pristup ne pokazuje <b>kako</b> algoritam zapravo „gradi“ rešenje.  
Induktivni pristup nam omogućava da vidimo kako se rezultat razvija —  
od prvog broja, zatim drugog, i tako redom — dok se ne pronađe najmanja vrednost.
</p>

<h2>Analiza problema</h2>
<p>
Ako želimo da pronađemo najmanju vrednost među n brojeva, možemo razmišljati ovako:  
Najmanji od svih n brojeva je onaj koji je manji između poslednjeg učitanog broja i minimuma prethodnih n−1 brojeva.  
Dakle, ako znamo minimum za manji skup, lako možemo izračunati minimum za veći.
</p>

<div class="napomena">
<p><b>Osnovni slučaj</b> — kada je n = 0, nema više brojeva za poređenje i trenutni minimum je konačan rezultat.</p>
<p><b>Induktivni korak</b> — uporedi novi broj sa trenutnim minimumom i manju vrednost prosledi sledećem rekurzivnom pozivu.</p>
</div>

<h2>Pravilan pristup</h2>
<p>
Koristićemo <b>repno–rekurzivnu funkciju</b> koja u svakom koraku obrađuje po jedan broj i prosleđuje trenutni minimum dalje.
</p>

<div class="napomena">
<p><b>m</b> — trenutni minimum do sada pročitanih brojeva,</p>
<p><b>n</b> — broj preostalih brojeva koje treba učitati.</p>
</div>

<p>
Kada n postane 0, svi brojevi su obrađeni i funkcija vraća konačan minimum.
</p>

<xmp class="primer_ta">
int Min(int m, int n)
{
    if (n == 0)
        return m; // osnovni slučaj
    int t = int.Parse(Console.ReadLine());
    return Min(Math.Min(m, t), n - 1); // induktivni korak
}

int Min(int n)
{
    return Min(int.MaxValue, n);
}

// Ulaz: broj n (broj merenja) i zatim n temperatura
// Izlaz: najmanja temperatura
</xmp>

<h2>Objašnjenje toka izvršavanja</h2>
<p>
Zamisli da unosimo 5 temperatura: 3, 8, 1, 2 i 5.  
Evo kako funkcija „razmišlja“ korak po korak:
</p>

<ul>
  <li>Min(∞, 5) → učitavamo 3 → novi minimum = 3</li>
  <li>Min(3, 4) → učitavamo 8 → minimum ostaje 3</li>
  <li>Min(3, 3) → učitavamo 1 → novi minimum = 1</li>
  <li>Min(1, 2) → učitavamo 2 → minimum ostaje 1</li>
  <li>Min(1, 1) → učitavamo 5 → minimum ostaje 1</li>
  <li>Min(1, 0) → kraj rekurzije → vraća rezultat 1</li>
</ul>

<p>
Kada rekurzija stigne do kraja, rezultat je <b>1</b> —  
to znači da je najniža temperatura među unetima <code>3, 8, 1, 2, 5</code> upravo <b>1</b>.
</p>

<h2>Primeri</h2>
<table class="tabela">
<thead>
<tr><th>Ulaz</th><th>Očekivani izlaz</th></tr>
</thead>
<tbody>
<tr><td>5<br>3 8 1 2 5</td><td>1</td></tr>
<tr><td>4<br>10 7 15 9</td><td>7</td></tr>
<tr><td>3<br>-2 -5 0</td><td>-5</td></tr>
</tbody>
</table>

<h2>Pitanja za samoproveru</h2>
<ul>
  <li>Šta predstavlja osnovni slučaj u ovom algoritmu i zašto je važan?</li>
  <li>Zašto se parametar <code>m</code> prosleđuje kroz svaki poziv funkcije?</li>
  <li>Kako funkcija zna kada treba da se zaustavi?</li>
  <li>Šta bi se desilo ako bismo slučajno koristili <code>n + 1</code> umesto <code>n − 1</code>?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Napiši funkciju koja pronalazi maksimalnu vrednost n brojeva (najvišu temperaturu).<br><br>
2. Prilagodi funkciju tako da brojevi budu u nizu, a ne da se unose sa tastature.<br><br>
3. Napiši verziju koja računa razliku između maksimalne i minimalne vrednosti.<br><br>
4. Objasni kako se u svakom od ovih zadataka koristi induktivni princip.
</div>

<h1>Pomoć – Najniža temperatura</h1>

<div class="napomena">
Induktivni pristup znači da rešenje gradiš postepeno.  
Svaki novi broj se poredi sa trenutnim minimumom — manji od njih postaje „privremeni rezultat“.  
Kada više nema brojeva za poređenje, algoritam vraća konačnu vrednost minimuma.
</div>

<p>
Ako ti je teško da razumeš tok, probaj sam da simuliraš nekoliko koraka sa manjim brojem ulaza (na primer 3 broja).  
Zapiši svaki poziv funkcije i vrednost koju ona vraća — tako ćeš videti kako se rekurzija „odmotava“ i dođe do konačnog rešenja.
</p>
