<h1>Drugi na rang listi</h1>

<h2>Motivacija</h2>
<p>
Na takmičenjima i rang listama često nas ne zanima samo najbolji rezultat, već i <b>drugi najbolji</b>.  
Na primer, ako imamo rezultate 87, 95, 90, 100, 92 – želimo da pronađemo drugi po veličini rezultat, koji je odmah iza najboljeg.  
Ovaj zadatak nam pokazuje kako se to može uraditi korak po korak, koristeći induktivno-rekurzivni pristup.
</p>

<h2>Naivno rešenje</h2>
<p>
Jednostavno rešenje bilo bi da smestimo sve rezultate u niz, sortiramo ga i uzmemo drugi element s kraja.  
Iako ovo radi, to nije ni najefikasnije ni najpoučnije rešenje.  
Induktivni pristup nam omogućava da drugi maksimum pronađemo bez sortiranja – tako što u svakom koraku pratimo samo dva najveća broja.
</p>

<h2>Analiza problema</h2>
<p>
Ako imamo n brojeva, dovoljno je da u svakom trenutku znamo samo <b>dva najveća</b> broja do tog trenutka:  
trenutni maksimum i drugi maksimum.  
Kada učitamo novi broj, proveravamo:
</p>

<div class="napomena">
<p>• Ako je novi broj veći od trenutnog maksimuma – postaje novi maksimum, a stari maksimum postaje drugi.</p>
<p>• Ako je novi broj manji od maksimuma, ali veći od drugog maksimuma – postaje novi drugi maksimum.</p>
<p>• Ako nije veći ni od jednog, ništa se ne menja.</p>
</div>

<h2>Pravilan pristup</h2>
<p>
Koristićemo repno-rekurzivnu funkciju koja u svakom koraku obrađuje po jedan broj i ažurira trenutna dva maksimuma.
</p>

<xmp class="primer_ta">
int Drugi(int n, int prviMaks, int drugiMaks)
{
    if (n == 0)
        return drugiMaks;

    int x = int.Parse(Console.ReadLine());

    if (x > prviMaks)
        return Drugi(n - 1, x, prviMaks);
    else if (x > drugiMaks)
        return Drugi(n - 1, prviMaks, x);
    else
        return Drugi(n - 1, prviMaks, drugiMaks);
}

int Drugi(int n)
{
    return Drugi(n, -1, -1);
}

// Ulaz: broj n i n rezultata (celih brojeva)
// Izlaz: drugi najveći broj u unetoj listi
</xmp>

<h2>Objašnjenje toka izvršavanja</h2>
<p>
Tok izvršavanja možemo pratiti na primeru:<br>
n = 5<br>
Uneti brojevi: 3, 8, 1, 2, 5
</p>

<p>
Drugi(5, -1, -1) => učitavamo 3, prviMaks = 3, drugiMaks = -1<br>
Drugi(4, 3, -1) => učitavamo 8, x > prviMaks → novi maksimum = 8, drugi = 3<br>
Drugi(3, 8, 3) => učitavamo 1, ne menja se ništa (1 < 3)<br>
Drugi(2, 8, 3) => učitavamo 2, ne menja se ništa (2 < 3)<br>
Drugi(1, 8, 3) => učitavamo 5, x > drugiMaks → drugiMaks = 5<br>
Drugi(0, 8, 5) => n = 0, kraj rekurzije, rezultat = 5<br>
</p>

<p>
Dakle, funkcija se završava kada je <b>n = 0</b> i vraća vrednost <b>5</b>.  
To znači da je za unete brojeve 3, 8, 1, 2, 5 drugi najveći broj <b>5</b>.
</p>

<h2>Primeri</h2>
<table class="tabela">
<thead>
<tr><th>Ulaz</th><th>Očekivani izlaz</th></tr>
</thead>
<tbody>
<tr><td>5<br>3 8 1 2 5</td><td>5</td></tr>
<tr><td>4<br>10 7 15 9</td><td>10</td></tr>
<tr><td>6<br>1 5 4 2 3 7</td><td>5</td></tr>
</tbody>
</table>

<h2>Pitanja za samoproveru</h2>
<p>Koja su dva ključna parametra funkcije i šta predstavljaju?</p>
<p>Zašto funkcija mora da poredi novi broj sa oba trenutna maksimuma?</p>
<p>Kako funkcija zna kada da se zaustavi?</p>
<p>Šta bi se desilo ako bi svi brojevi bili isti?</p>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Napiši funkciju koja pronalazi treći po veličini broj u nizu.<br>
2. Napiši funkciju koja pronalazi i najmanji i najveći broj istovremeno.<br>
3. Prilagodi funkciju tako da brojevi budu prosleđeni kroz niz, a ne sa tastature.<br>
4. Objasni kako se u svakom od ovih zadataka koristi induktivni korak.
</div>

<h2>Pomoć</h2>
<div class="napomena">
Induktivni pristup u ovom zadatku ogleda se u tome da svaki novi broj ažurira samo ono što je potrebno –  
bilo maksimum, bilo drugi maksimum – bez ponovnog prolaska kroz sve prethodne vrednosti.  
Na taj način funkcija „pamti“ dva ključna podatka i rekurzivno ih prenosi sve dok se ne obrade svi elementi.
</div>