<h1>Drugi na rang listi</h1>

<h2>Motivacija</h2>
<p>
Na takmičenjima i rang listama često nas ne zanima samo najbolji rezultat, već i <b>drugi najbolji</b>.  
Na primer, ako imamo rezultate <code>87, 95, 90, 100, 92</code> – želimo da pronađemo rezultat koji je odmah ispod najboljeg.  
Takvi zadaci su važni jer nas uče kako da prepoznamo obrasce i pronađemo rešenje bez dodatnih koraka, poput sortiranja.  
</p>

<p>
Ovaj zadatak nam pokazuje kako da <b>postepeno</b> pronađemo drugi maksimum, koristeći <b>induktivno–rekurzivno razmišljanje</b>:  
rešenje se gradi korak po korak, dok funkcija u svakom koraku pamti samo ono što joj je potrebno — dva najveća broja do tada.
</p>

<h2>Naivno rešenje</h2>
<p>
Najjednostavnije rešenje bilo bi da smestimo sve rezultate u niz, sortiramo ih i uzmemo drugi element s kraja.  
Iako ovakav pristup funkcioniše, on je <b>neefikasan</b> (zahteva sortiranje svih brojeva) i ne otkriva <em>logiku</em> 
kako drugi maksimum možemo pronaći „u hodu“.  
Induktivni pristup nam omogućava da to uradimo <b>bez sortiranja</b>, prateći samo dva broja — najveći i drugi najveći.
</p>

<h2>Analiza problema</h2>
<p>
Ako imamo <i>n</i> brojeva, dovoljno je da u svakom trenutku znamo samo <b>dva najveća</b>:  
trenutni maksimum i drugi maksimum.  
Kada učitamo novi broj, proveravamo sledeće:
</p>

<div class="napomena">
<p>• Ako je novi broj veći od trenutnog maksimuma — on postaje novi maksimum, a stari maksimum postaje drugi.</p>
<p>• Ako je novi broj manji od maksimuma, ali veći od drugog maksimuma — on postaje novi drugi maksimum.</p>
<p>• Ako nije veći ni od jednog, ništa se ne menja.</p>
</div>

<p>
Na taj način svaki korak zavisi samo od prethodnog stanja —  
što je suština <b>induktivnog pristupa</b>.
</p>

<h2>Pravilan pristup</h2>
<p>
Zadatak možemo rešiti i repnom rekurzijom (koju neki kompilatori automatski optimizuju i pretvaraju u
iteraciju). Definisaćemo rekurzivnu funkciju koja prima dva najveća elementa u delu niza koji je obrađen
pre poziva te funkcije i broj n preostalih elemenata koje treba obraditi. Ako je n = 0 ceo niz je obrađen i
funkcija može da vrati dotadašnjih drugi element po veličini. U suprotnom, učitava se naredni element
x i vrši se rekurzivni poziv za preostalih n − 1 elemenata niza, pri čemu se po potrebi ažuriraju dva
do tada najveća elementa. Ako je učitani element x veći od dotadašnjeg prvog maksimuma, onda je on novi
prvi maksimum, a dotadašnji prvi maksimum je novi drugi maksimum. U suprotnom, ako je učitani element
x veći od dotadašnjeg drugog maksimuma, tada se prvi maksimum ne menja, a element x postaje novi drugi
maksimum. U suprotnom se ne menjaju ni prvi ni drugi maksimum.
</p>

<xmp class="primer_ta">
using System;

class Program
{
    // Rekurzivna funkcija za pronalaženje drugog maksimuma
    static int Drugi(int n, int prviMaks, int drugiMaks)
    {
        if (n == 0)
            return drugiMaks;

        int x = int.Parse(Console.ReadLine());

        if (x > prviMaks)
            return Drugi(n - 1, x, prviMaks);
        else if (x > drugiMaks)
            return Drugi(n - 1, prviMaks, x);
        else
            return Drugi(n - 1, prviMaks, drugiMaks);
    }

    // Pomoćna funkcija za inicijalizaciju
    static int Drugi(int n)
    {
        return Drugi(n, int.MinValue, int.MinValue);
    }

    static void Main()
    {
        // Učitavanje broja elemenata
        int n = int.Parse(Console.ReadLine());

        // Ispis drugog maksimuma
        Console.WriteLine(Drugi(n));
    }
}
</xmp>

<div class="napomena">
Kao početne vrednosti koristimo <code>int.MinValue</code> da bi rešenje bilo ispravno i za negativne brojeve.
</div>

<h2>Objašnjenje toka izvršavanja</h2>
<p>
Zamislimo da unosimo 5 brojeva: 3, 8, 1, 2, 5.  
Funkcija radi ovako:
</p>

<ul>
  <li>Drugi(5, -∞, -∞) → učitavamo 3 → prviMaks = 3, drugiMaks = -∞</li>
  <li>Drugi(4, 3, -∞) → učitavamo 8 → novi maksimum = 8, drugiMaks = 3</li>
  <li>Drugi(3, 8, 3) → učitavamo 1 → ništa se ne menja</li>
  <li>Drugi(2, 8, 3) → učitavamo 2 → ništa se ne menja</li>
  <li>Drugi(1, 8, 3) → učitavamo 5 → novi drugi maksimum = 5</li>
  <li>Drugi(0, 8, 5) → n = 0 → vraća rezultat 5</li>
</ul>

<p>
Konačan rezultat je <b>5</b>, što znači da je drugi najveći broj među unetima 3, 8, 1, 2, 5 upravo <b>5</b>.
</p>

<h2>Primeri</h2>
<table class="tabela">
<thead>
<tr><th>Ulaz</th><th>Očekivani izlaz</th></tr>
</thead>
<tbody>
<tr><td>5<br>3 8 1 2 5</td><td>5</td></tr>
<tr><td>4<br>10 7 15 9</td><td>10</td></tr>
<tr><td>6<br>1 5 4 2 3 7</td><td>5</td></tr>
</tbody>
</table>

<h2>Pitanja za samoproveru</h2>
<ul>
  <li>Koja su dva ključna parametra funkcije i šta oni predstavljaju?</li>
  <li>Zašto funkcija mora da poredi novi broj sa oba trenutna maksimuma?</li>
  <li>Kako funkcija zna da se treba zaustaviti?</li>
  <li>Šta bi se desilo ako bi svi brojevi bili jednaki?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Napiši funkciju koja pronalazi <b>treći</b> po veličini broj u nizu.<br><br>
2. Napiši funkciju koja pronalazi istovremeno <b>najveći i najmanji</b> broj.<br><br>
3. Prilagodi funkciju tako da brojevi budu <b>u nizu</b> umesto da se unose sa tastature.<br><br>
4. Objasni kako se u svakom od ovih zadataka koristi induktivni korak.
</div>

<h1>Pomoć – Drugi na rang listi</h1>

<div class="napomena">
Induktivni pristup u ovom zadatku znači da svaka nova vrednost ažurira samo ono što je potrebno —  
bilo maksimum, bilo drugi maksimum.  
Funkcija ne mora da „pamti“ sve brojeve, već samo dva ključna podatka,  
koja rekurzivno prenosi dok ne obradi sve elemente.
</div>

<p>
Ako ti je teško da razumeš tok rekurzije, probaj sam da zapišeš korake za 4 unosa,  
npr. 7, 5, 9, 8 — i posmatraj kako se maksimum i drugi maksimum menjaju u svakom koraku.
</p>
