<h1>Prva negativna temperatura</h1>

<h2>Motivacija</h2>
<p>
Zamisli da svakog dana meriš temperaturu.  
Želiš da znaš <b>kada se prvi put temperatura spustila ispod nule</b> — koji je to dan?  
Takav zadatak je čest i u programiranju: potrebno je pronaći <b>prvi element koji ispunjava određeni uslov</b>.  
U ovom slučaju, to je prva negativna vrednost.  
</p>

<p>
Ovaj problem je odličan primer kako rekurzija može da zameni klasičnu petlju i kako kompjuter može sam da “pamti” u kom koraku se trenutno nalazi,  
bez potrebe da mi ručno upravljamo brojačem.
</p>

<h2>Naivno rešenje</h2>
<p>
Jedan način je da koristimo petlju koja redom prolazi kroz sve temperature i proverava svaku dok ne naiđe na prvu negativnu.  
Ovakav pristup funkcioniše, ali ne pokazuje <b>induktivno razmišljanje</b> — ne razlaže problem na manje korake.  
Kod rekurzije, svaka funkcija obrađuje <b>po jedan element</b> i zatim prepušta ostatak sledećem koraku.
</p>

<h2>Analiza problema</h2>
<p>
Zadatak možemo izraziti kao niz manjih odluka:
</p>
<ul>
  <li>Ako nema više temperatura za proveru — nismo pronašli negativnu vrednost, pa vraćamo -1.</li>
  <li>Ako je trenutna temperatura negativna — odmah vraćamo njen redni broj.</li>
  <li>Ako nije negativna — prelazimo na sledeću temperaturu i tražimo dalje.</li>
</ul>

<div class="napomena">
<p><b>Osnovni slučaj</b> — kada smo proverili sve temperature (i > n), vraćamo -1 jer negativna nije pronađena.</p>
<p><b>Induktivni korak</b> — proveravamo trenutnu temperaturu; ako nije negativna, pozivamo funkciju za sledeću poziciju.</p>
</div>

<h2>Pravilan pristup</h2>
<p>
Zadatak se može rešiti definisanjem repno-rekurzivne funkcije, koja je veoma bliska iterativnom algoritmu. Funkcija prima tekuću poziciju i i ukupan broj elemenata n i treba da učita n − i + 1 elemenata
(u intervalu pozicija [i, n]) i odredi poziciju prvog negativnog među njima (ili da vrati -1 ako među njima
nema negativnih). U inicijalnom pozivu ćemo postaviti vrednost i = 1, da bi funkcija odredila poziciju
prvog negativnog elementa u intervalu pozicija [1, n]. Ako je i > n, tada nema elemenata, pa funkcija može
da vrati -1. U suprotnom se učitava prvi element (on je na poziciji i). Ako je on negativan, to je ujedno
i prvi negativan i funkcija vraća poziciju i. U suprotnom se vrši rekurzivni poziv da bi se odredila
pozicija prvog negativnog u delu niza između pozicija i + 1 i n.
</p>

<xmp class="primer_ta">
using System;

class Program
{
  // Funkcija koja pronalazi poziciju prve negativne temperature
  static int PrviNegativan(int i, int n)
  {
    if (i > n)
      return -1;

    int x = int.Parse(Console.ReadLine());
    if (x < 0)
      return i;
    else
      return PrviNegativan(i + 1, n);
  }

  // Pomoćna funkcija za inicijalni poziv
  static int PrviNegativan(int n)
  {
    return PrviNegativan(1, n);
  }

  static void Main()
  {
    int n = int.Parse(Console.ReadLine());
    Console.WriteLine(PrviNegativan(n));
  }
}

</xmp>

<p>
Ovaj algoritam radi tako što se u svakom koraku proverava jedan broj.  
Ako je negativan — vraćamo poziciju.  
Ako nije — zadatak se svodi na isti problem, ali za preostalih n−1 brojeva.
</p>

<h2>Objašnjenje toka izvršavanja</h2>
<p>
Posmatrajmo primer kada je n = 5 i unete temperature: 3, 8, -2, 1, 0
</p>

<ul>
  <li>PrviNegativan(1, 5) → učitavamo 3 → nije negativna → prelazimo na 2</li>
  <li>PrviNegativan(2, 5) → učitavamo 8 → nije negativna → prelazimo na 3</li>
  <li>PrviNegativan(3, 5) → učitavamo -2 → negativna! → vraćamo 3</li>
</ul>

<p>
Dakle, funkcija se zaustavlja čim naiđe na prvu negativnu temperaturu i vraća njen redni broj — u ovom slučaju <b>3</b>.
</p>

<h2>Primeri</h2>
<table class="tabela">
<thead>
<tr><th>Ulaz</th><th>Očekivani izlaz</th></tr>
</thead>
<tbody>
<tr><td>5<br>3 8 -2 1 0</td><td>3</td></tr>
<tr><td>4<br>1 2 3 4</td><td>-1</td></tr>
<tr><td>6<br>5 4 3 2 -1 -5</td><td>5</td></tr>
</tbody>
</table>

<h2>Pitanja za samoproveru</h2>
<ul>
  <li>Koji je osnovni slučaj u ovom algoritmu?</li>
  <li>Zašto funkcija odmah vraća poziciju kada pronađe negativan broj?</li>
  <li>Kako funkcija zna kada da se zaustavi?</li>
  <li>Kako bi izgledalo iterativno rešenje istog problema?</li>
</ul>

<h2>Zadaci za vežbu</h2>
<div class="zadatak">
1. Napiši funkciju koja pronalazi <b>prvu pozitivnu temperaturu</b>.<br><br>
2. Napiši funkciju koja pronalazi <b>poslednju negativnu temperaturu</b>.<br><br>
3. Napiši funkciju koja vraća <b>ukupan broj negativnih temperatura</b>.<br><br>
4. Objasni gde se u svakom zadatku koristi induktivni korak.
</div>

<h1>Pomoć – Prva negativna temperatura</h1>

<div class="napomena">
Induktivni pristup znači da u svakom koraku rešavaš manji deo problema.  
Ako trenutna temperatura nije negativna, problem se svodi na preostale merenja.  
Kada naiđeš na prvu negativnu vrednost — tu se rekurzija završava i rezultat se vraća unazad kroz sve pozive.
</div>

<p>
Ako želiš da proveriš da li razumeš algoritam, probaj da nacrtaš stablo poziva funkcije za unose 5, 4, -3, 2.  
Videćeš kako se funkcija „penje“ nazad tek kad pronađe negativan broj.
</p>
